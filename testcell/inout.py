# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/01a_arguments.ipynb.

# %% auto 0
__all__ = ['optionalFind', 'count_char', 'count_delta', 'split_and_strip', 'process_inout', 'separate_args_and_inout',
           'validate_and_update_inputs']

# %% ../nbs/01a_arguments.ipynb 6
def optionalFind(x,cc,reverse=False):
    if isinstance(cc,str): cc = [cc] #Â listify
    t = [(x.rfind(c) if reverse else x.find(c),c) for c in cc]
    t = [(f,c) for f,c in t if f != -1]
    if len(t)==0: return None
    return max(t) if reverse else min(t)

# %% ../nbs/01a_arguments.ipynb 9
def count_char(x,c):
    # Count how many times c appears in x
    return sum(map(lambda y: y==c,x))

# %% ../nbs/01a_arguments.ipynb 11
def count_delta(x,a='(',b=')'):
    # Return the difference between the count of "a" and "b".
    return count_char(x,a) - count_char(x,b)

# %% ../nbs/01a_arguments.ipynb 14
def split_and_strip(x,splitter):
    t = [t.strip() for t in x.split(splitter)]
    if t==['']: return []
    return t

# %% ../nbs/01a_arguments.ipynb 17
def process_inout(x,splitter='->'):
    if x is None: return None
    t = split_and_strip(x,splitter)
    for v,c,n in zip(t,map(count_delta,t),map(lambda s: count_char(s,'('),t)): 
        if n>1: raise ValueError(f'Too much parenthesis on "{v}"')
        if c>0: raise ValueError(f'Missing closing parenthesis on "{v}"')
    t = [x[1:-1] for x in t]
    if len(t)==0: raise ValueError('No groups available')
    if len(t)>2: raise ValueError(f'You shouold have only one "{splitter}" symbol')
    if len(t)==1: return split_and_strip(t[0],','),[]
    if len(t)==2: return split_and_strip(t[0],','),split_and_strip(t[1],',')

# %% ../nbs/01a_arguments.ipynb 19
def separate_args_and_inout(x):
    if x is None: return None
    if (start_t := optionalFind(x,['(','->'],reverse=False)) and (end_t := optionalFind(x,[')','->'],reverse=True)):
        start,_ = start_t
        end, c = end_t
        length = len(c)
        return x[:start]+x[end+length:],x[start:end+length]
    return x,None

# %% ../nbs/01a_arguments.ipynb 22
def validate_and_update_inputs(inputs:list,state:dict,)->dict:
    s = set(inputs)
    ret = {}
    for k in inputs:
        if k not in state: raise ValueError(f'Unable to find object "{k}" in current state')
        ret[k] = state[k]
    return ret
